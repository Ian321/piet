{\bf Piet} to graficzny język programowania autorstwa {\bf Davida Morgan-Mar}. {\bf Interpreter} został stworzony przez {\bf Tomasza Ducina}. Poniższy tekst pochodzi ze wstępu do rozdziału 1, {\em \char`\"{}Język Piet\char`\"{}\/}, pracy magisterskiej Tomasza Ducina pt. {\em \char`\"{}Języki ezoteryczne Piet i Salvador jako uniwersalne maszyny obliczeniowe\char`\"{}\/}.

Język zawdzięcza swoją nazwę imieniu malarza, Pieta Mondriana, malarza który zapoczątkował gałąź geometrycznego malarstwa abstrakcyjnego. Z założenia, programy mają przypominać obrazy malarstwa abstrakcyjnego.

Interpreter Pieta wyposażony jest w głowicę, która odczytuje piksle z obrazu, przesuwając się po nim. Dane przetwarzane w trakcie działania programu są umieszczane na stosie.

Sposób pisania kodu (a szczególnie algorytmów obliczeniowych) różni się bardzo znacząco od programowania w innych językach nie tylko z powodu iż Piet jest językiem graficznym. Najważniejszymi dwiema cechami egzekucji kodu są: \mbox{[}1\mbox{]} porównywanie sąsiednich kolorów w celu wyboru instrukcji do wykonania (za pomocą głowicy) oraz \mbox{[}2\mbox{]} tzw. bloki kolorów (w których sąsiadujące piksle mają ten sam kolor). Na kod Pieta należy patrzeć „całościowo”, ogarniając kształt całości obrazu, a nie tylko dowolne niewielkie fragmenty. To jest właśnie zasadnicza różnica w sposobie programowania między Pietem i językami imperatywnymi (a również Salvadorem). W uproszczeniu, egzekucja kodu imperatywnego może wyglądać tak: „podstaw wartość pod zmienną, następnie na jej podstawie oblicz kolejne wyrażenie i podstaw pod inną zmienną. Teraz, mając przygotowane wszystkie pomocnicze wartości, sprawdzamy jedną z nich: jeśli sprawdzana wartość jest dodatnia, wykonaj blok instrukcji nr 1, jeśli ujemna, wykonaj blok nr 2, jeśli zero, wyświetl komunikat”. W językach imperatywnych mamy ściśle określoną, liniową kolejność wykonywania instrukcji, łatwo nam ją kontrolować. W Piecie natomiast kierunek w którym przesunie się głowica (czyli kolejność wykonywania instrukcji) zależy od trzech czynników: \mbox{[}1\mbox{]} aktualnego kierunku ruchu głowicy, \mbox{[}2\mbox{]} kolorów po których porusza się głowica i \mbox{[}3\mbox{]} kształtu bloków kolorów. Sprawia to, że programowanie skomplikowanych algorytmów jest stosunkowo trudne. 